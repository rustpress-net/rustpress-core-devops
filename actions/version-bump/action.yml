name: 'Version Bump'
description: 'Determine version bump and release type from commits'

inputs:
  version_bump:
    description: 'Version bump type (auto, patch, minor, major)'
    required: false
    default: 'auto'
  release_type:
    description: 'Release type (auto, release, pre-release, draft)'
    required: false
    default: 'auto'
  version_file:
    description: 'File to read version from (Cargo.toml, package.json, theme.json, or VERSION)'
    required: false
    default: 'Cargo.toml'

outputs:
  current_version:
    description: 'Current version'
    value: ${{ steps.version.outputs.current_version }}
  new_version:
    description: 'New version'
    value: ${{ steps.version.outputs.new_version }}
  bump_type:
    description: 'Version bump type used'
    value: ${{ steps.version.outputs.bump_type }}
  release_type:
    description: 'Release type'
    value: ${{ steps.version.outputs.release_type }}
  should_release:
    description: 'Whether to create a release'
    value: ${{ steps.version.outputs.should_release }}

runs:
  using: 'composite'
  steps:
    - name: Determine version
      id: version
      shell: bash
      run: |
        # Get current version based on file type
        VERSION_FILE="${{ inputs.version_file }}"
        if [[ "$VERSION_FILE" == "Cargo.toml" ]]; then
          CURRENT_VERSION=$(grep -m1 '^version = ' Cargo.toml | sed 's/version = "\(.*\)"/\1/')
        elif [[ "$VERSION_FILE" == "package.json" ]]; then
          CURRENT_VERSION=$(jq -r '.version' package.json)
        elif [[ "$VERSION_FILE" == "theme.json" ]]; then
          CURRENT_VERSION=$(jq -r '.version' theme.json)
        elif [[ "$VERSION_FILE" == "VERSION" ]]; then
          CURRENT_VERSION=$(cat VERSION | tr -d '[:space:]')
        else
          CURRENT_VERSION="1.0.0"
        fi
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

        # Get commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -z "$LAST_TAG" ]; then
          COMMITS=$(git log --pretty=format:"%s" HEAD)
        else
          COMMITS=$(git log --pretty=format:"%s" ${LAST_TAG}..HEAD)
        fi

        # Determine release type
        INPUT_RELEASE_TYPE="${{ inputs.release_type }}"
        if [ "$INPUT_RELEASE_TYPE" != "" ] && [ "$INPUT_RELEASE_TYPE" != "auto" ]; then
          RELEASE_TYPE="$INPUT_RELEASE_TYPE"
        else
          if echo "$COMMITS" | grep -qi "\[release\]"; then
            RELEASE_TYPE="release"
          elif echo "$COMMITS" | grep -qi "\[pre-release\]"; then
            RELEASE_TYPE="pre-release"
          elif echo "$COMMITS" | grep -qi "\[draft\]"; then
            RELEASE_TYPE="draft"
          else
            RELEASE_TYPE="none"
          fi
        fi
        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

        if [ "$RELEASE_TYPE" = "none" ]; then
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "bump_type=none" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "should_release=true" >> $GITHUB_OUTPUT

        # Determine bump type
        INPUT_BUMP="${{ inputs.version_bump }}"
        if [ "$INPUT_BUMP" != "" ] && [ "$INPUT_BUMP" != "auto" ]; then
          BUMP_TYPE="$INPUT_BUMP"
        else
          if echo "$COMMITS" | grep -qiE "^(feat|feature)!:|BREAKING CHANGE"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -qiE "^(feat|feature)(\(.*\))?:"; then
            BUMP_TYPE="minor"
          else
            BUMP_TYPE="patch"
          fi
        fi
        echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT

        # Calculate new version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
        case $BUMP_TYPE in
          major) NEW_VERSION="$((MAJOR + 1)).0.0" ;;
          minor) NEW_VERSION="${MAJOR}.$((MINOR + 1)).0" ;;
          patch) NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))" ;;
        esac
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
